module.exports = {

"[project]/.next-internal/server/app/api/todoist/projects/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[project]/lib/todoist-api.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "TodoistApiClient": (()=>TodoistApiClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$doist$2f$todoist$2d$api$2d$typescript$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@doist/todoist-api-typescript/dist/index.js [app-route] (ecmascript)");
;
// Initialize Todoist API client
const api = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$doist$2f$todoist$2d$api$2d$typescript$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TodoistApi"](process.env.TODOIST_API_KEY);
class TodoistApiClient {
    // Fetch all projects
    static async getProjects() {
        try {
            const response = await api.getProjects();
            console.log('Projects response:', response);
            console.log('Projects response type:', typeof response);
            console.log('Projects response keys:', Object.keys(response || {}));
            // Handle different response formats
            let projects;
            if (Array.isArray(response)) {
                projects = response;
            } else if (response && typeof response === 'object') {
                // Try common pagination field names
                projects = response.data || response.items || response.projects || response.results || [];
            } else {
                projects = [];
            }
            console.log('Extracted projects:', projects);
            console.log('Projects array length:', projects.length);
            // Filter out null/undefined items
            const validProjects = projects.filter((project)=>project && project.id);
            return validProjects.map((project)=>({
                    id: project.id,
                    name: project.name,
                    color: project.color,
                    isInboxProject: project.inboxProject || false,
                    parentId: project.parentId || undefined
                }));
        } catch (error) {
            console.error('Error fetching projects:', error);
            throw new Error('Failed to fetch projects');
        }
    }
    // Fetch all labels
    static async getLabels() {
        try {
            const response = await api.getLabels();
            console.log('Labels response:', response);
            console.log('Labels response keys:', Object.keys(response || {}));
            // Handle different response formats
            let labels;
            if (Array.isArray(response)) {
                labels = response;
            } else if (response && typeof response === 'object') {
                // Try common pagination field names
                labels = response.data || response.items || response.labels || response.results || [];
            } else {
                labels = [];
            }
            console.log('Extracted labels:', labels);
            // Filter out null/undefined items
            const validLabels = labels.filter((label)=>label && label.id);
            return validLabels.map((label)=>({
                    id: label.id,
                    name: label.name,
                    color: label.color
                }));
        } catch (error) {
            console.error('Error fetching labels:', error);
            throw new Error('Failed to fetch labels');
        }
    }
    // Fetch active tasks (inbox tasks or all tasks)
    static async getTasks(filter) {
        try {
            const response = filter ? await api.getTasks({
                filter
            }) : await api.getTasks();
            console.log('Tasks response:', response);
            console.log('Tasks response keys:', Object.keys(response || {}));
            // Handle different response formats
            let tasks;
            if (Array.isArray(response)) {
                tasks = response;
            } else if (response && typeof response === 'object') {
                // Try common pagination field names
                tasks = response.data || response.items || response.tasks || response.results || [];
            } else {
                tasks = [];
            }
            console.log('Extracted tasks:', tasks);
            // Filter out null/undefined items
            const validTasks = tasks.filter((task)=>task && task.id);
            return validTasks.map((task)=>({
                    id: task.id,
                    content: task.content,
                    description: task.description || '',
                    projectId: task.projectId,
                    priority: task.priority,
                    labels: task.labels || [],
                    due: task.due ? {
                        date: task.due.date,
                        string: task.due.string,
                        datetime: task.due.datetime || undefined
                    } : undefined,
                    deadline: task.deadline ? {
                        date: task.deadline.date,
                        string: task.deadline.string
                    } : undefined,
                    createdAt: task.createdAt,
                    isCompleted: task.isCompleted || false
                }));
        } catch (error) {
            console.error('Error fetching tasks:', error);
            throw new Error('Failed to fetch tasks');
        }
    }
    // Get inbox tasks specifically
    static async getInboxTasks() {
        return this.getTasks();
    }
    // Get tasks for a specific project
    static async getProjectTasks(projectId) {
        try {
            const response = await api.getTasks({
                projectId
            });
            console.log(`Tasks response for project ${projectId}:`, response);
            // Handle different response formats
            let tasks;
            if (Array.isArray(response)) {
                tasks = response;
            } else if (response && typeof response === 'object') {
                // Try common pagination field names
                tasks = response.data || response.items || response.tasks || response.results || [];
            } else {
                tasks = [];
            }
            console.log(`Extracted tasks for project ${projectId}:`, tasks);
            // Filter out null/undefined items
            const validTasks = tasks.filter((task)=>task && task.id);
            return validTasks.map((task)=>({
                    id: task.id,
                    content: task.content,
                    description: task.description || '',
                    projectId: task.projectId,
                    priority: task.priority,
                    labels: task.labels || [],
                    due: task.due ? {
                        date: task.due.date,
                        string: task.due.string,
                        datetime: task.due.datetime || undefined
                    } : undefined,
                    deadline: task.deadline ? {
                        date: task.deadline.date,
                        string: task.deadline.string
                    } : undefined,
                    createdAt: task.createdAt,
                    isCompleted: task.isCompleted || false
                }));
        } catch (error) {
            console.error(`Error fetching tasks for project ${projectId}:`, error);
            throw new Error('Failed to fetch project tasks');
        }
    }
    // Move task to a different project using Sync API v9
    static async moveTaskToProject(taskId, projectId) {
        try {
            console.log('ðŸ”„ Moving task via Sync API:', {
                taskId,
                projectId
            });
            // Generate a unique UUID for the command
            const uuid = crypto.randomUUID();
            const response = await fetch('https://api.todoist.com/sync/v9/sync', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${process.env.TODOIST_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    commands: [
                        {
                            type: 'item_move',
                            args: {
                                id: taskId,
                                project_id: projectId
                            },
                            uuid: uuid
                        }
                    ]
                })
            });
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Sync API move failed:', response.status, errorText);
                throw new Error(`Sync API move failed: ${response.status} ${errorText}`);
            }
            const result = await response.json();
            console.log('âœ… Sync API move result:', result);
            // Check if the command was successful
            if (result.sync_status && result.sync_status[uuid] === 'ok') {
                console.log('âœ… Task move confirmed successful');
                return true;
            } else {
                console.error('âŒ Task move failed:', result.sync_status);
                throw new Error(`Task move failed: ${JSON.stringify(result.sync_status)}`);
            }
        } catch (error) {
            console.error('âŒ Sync API move error:', error);
            throw error;
        }
    }
    // Update a task
    static async updateTask(taskId, updates) {
        try {
            console.log('TodoistApiClient.updateTask called with:', {
                taskId,
                updates
            });
            // Handle project move separately using Sync API
            if (updates.projectId && updates.projectId !== '') {
                try {
                    const projects = await this.getProjects();
                    const targetProject = projects.find((p)=>p.id === updates.projectId);
                    if (!targetProject) {
                        console.error('Target project not found:', updates.projectId);
                        console.log('Available projects:', projects.map((p)=>({
                                id: p.id,
                                name: p.name
                            })));
                        throw new Error(`Project with ID ${updates.projectId} not found`);
                    }
                    console.log('Target project found:', {
                        id: targetProject.id,
                        name: targetProject.name
                    });
                    // Use Sync API for project move
                    await this.moveTaskToProject(taskId, updates.projectId);
                } catch (moveError) {
                    console.error('âŒ Project move failed:', moveError);
                    throw new Error(`Failed to move task to project: ${moveError}`);
                }
            }
            // Handle deadline separately using Sync API
            if (updates.deadline !== undefined) {
                try {
                    console.log('ðŸ”„ Updating deadline via Sync API:', {
                        taskId,
                        deadline: updates.deadline
                    });
                    // Generate a unique UUID for the command
                    const uuid = crypto.randomUUID();
                    // Parse natural language date to ISO format
                    let deadlineDate = null;
                    if (updates.deadline) {
                        // First try to parse natural language using Todoist's due date parser
                        try {
                            const parseResponse = await api.addTask({
                                content: 'temp',
                                dueString: updates.deadline
                            });
                            if (parseResponse.due) {
                                deadlineDate = {
                                    date: parseResponse.due.date
                                };
                            }
                            // Delete the temporary task
                            await api.deleteTask(parseResponse.id);
                        } catch (parseError) {
                            console.error('Failed to parse deadline date:', parseError);
                            throw new Error('Invalid deadline date format');
                        }
                    }
                    const response = await fetch('https://api.todoist.com/sync/v9/sync', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${process.env.TODOIST_API_KEY}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            commands: [
                                {
                                    type: 'item_update',
                                    args: {
                                        id: taskId,
                                        deadline: deadlineDate
                                    },
                                    uuid: uuid
                                }
                            ]
                        })
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Sync API deadline update failed:', response.status, errorText);
                        throw new Error(`Sync API deadline update failed: ${response.status} ${errorText}`);
                    }
                    const result = await response.json();
                    console.log('âœ… Sync API deadline result:', result);
                    // Check if the command was successful
                    if (result.sync_status && result.sync_status[uuid] === 'ok') {
                        console.log('âœ… Deadline update confirmed successful');
                    } else {
                        console.error('âŒ Deadline update failed:', result.sync_status);
                        throw new Error(`Deadline update failed: ${JSON.stringify(result.sync_status)}`);
                    }
                } catch (deadlineError) {
                    console.error('âŒ Deadline update error:', deadlineError);
                    throw new Error(`Failed to update deadline: ${deadlineError}`);
                }
            }
            // Build updates object for other fields (excluding projectId and deadline)
            const cleanUpdates = {};
            if (updates.content !== undefined) cleanUpdates.content = updates.content;
            if (updates.description !== undefined) cleanUpdates.description = updates.description;
            if (updates.priority !== undefined) cleanUpdates.priority = updates.priority;
            if (updates.labels !== undefined) cleanUpdates.labels = updates.labels;
            if (updates.dueString !== undefined) cleanUpdates.dueString = updates.dueString;
            // Only update other fields if there are any
            if (Object.keys(cleanUpdates).length > 0) {
                console.log('ðŸ“ Updating task fields:', cleanUpdates);
                const result = await api.updateTask(taskId, cleanUpdates);
                console.log('âœ… Update task result:', result);
            } else {
                console.log('â„¹ï¸  No additional fields to update');
            }
            return true;
        } catch (error) {
            console.error('Error updating task:', error);
            console.error('Full error details:', JSON.stringify(error, null, 2));
            throw new Error('Failed to update task');
        }
    }
    // Close (complete) a task
    static async closeTask(taskId) {
        try {
            await api.closeTask(taskId);
            return true;
        } catch (error) {
            console.error('Error closing task:', error);
            throw new Error('Failed to close task');
        }
    }
    // Create a new task
    static async createTask(content, options) {
        try {
            const taskData = {
                content,
                ...options?.description && {
                    description: options.description
                },
                ...options?.projectId && {
                    projectId: options.projectId
                },
                ...options?.priority && {
                    priority: options.priority
                },
                ...options?.labels && {
                    labels: options.labels
                },
                ...options?.dueString && {
                    dueString: options.dueString
                }
            };
            const response = await api.addTask(taskData);
            return {
                id: response.id,
                content: response.content,
                description: response.description || '',
                projectId: response.projectId,
                priority: response.priority,
                labels: response.labels || [],
                due: response.due ? {
                    date: response.due.date,
                    string: response.due.string,
                    datetime: response.due.datetime || undefined
                } : undefined,
                deadline: response.deadline ? {
                    date: response.deadline.date,
                    string: response.deadline.string
                } : undefined,
                createdAt: response.createdAt || new Date().toISOString(),
                isCompleted: !!response.completedAt
            };
        } catch (error) {
            console.error('Error creating task:', error);
            throw new Error('Failed to create task');
        }
    }
    // Project metadata helpers
    static async getProjectMetadata(projectId) {
        try {
            const [tasks, projects] = await Promise.all([
                this.getProjectTasks(projectId),
                this.getProjects()
            ]);
            const project = projects.find((p)=>p.id === projectId);
            if (!project) return null;
            const metadataTask = tasks.find((task)=>task.labels.includes('project-metadata'));
            if (metadataTask) {
                // Extract category from labels
                let category = null;
                if (metadataTask.labels.includes('area-of-responsibility')) {
                    category = 'area';
                } else if (metadataTask.labels.includes('project-type')) {
                    category = 'project';
                }
                return {
                    description: metadataTask.description || '',
                    category,
                    priority: metadataTask.priority,
                    due: metadataTask.due,
                    deadline: metadataTask.deadline
                };
            }
            return {
                description: '',
                category: null,
                priority: null
            };
        } catch (error) {
            console.error('Error fetching project metadata:', error);
            return null;
        }
    }
    // Legacy method for backward compatibility
    static async getProjectDescription(projectId) {
        const metadata = await this.getProjectMetadata(projectId);
        return metadata?.description || null;
    }
    static async setProjectMetadata(projectId, metadata) {
        try {
            const [tasks, projects] = await Promise.all([
                this.getProjectTasks(projectId),
                this.getProjects()
            ]);
            const project = projects.find((p)=>p.id === projectId);
            if (!project) {
                throw new Error(`Project with ID ${projectId} not found`);
            }
            const existingMetadataTask = tasks.find((task)=>task.labels.includes('project-metadata'));
            if (existingMetadataTask) {
                // Update existing metadata task - preserve existing values for fields not being updated
                // Build labels array - preserve existing category if not being updated
                const preservedLabels = [
                    'project-metadata'
                ];
                if (metadata.category !== undefined) {
                    // Category is being explicitly set
                    if (metadata.category === 'area') {
                        preservedLabels.push('area-of-responsibility');
                    } else if (metadata.category === 'project') {
                        preservedLabels.push('project-type');
                    }
                } else {
                    // Preserve existing category labels
                    if (existingMetadataTask.labels.includes('area-of-responsibility')) {
                        preservedLabels.push('area-of-responsibility');
                    } else if (existingMetadataTask.labels.includes('project-type')) {
                        preservedLabels.push('project-type');
                    }
                }
                // Build update object - only include fields that are being updated
                const updateData = {
                    labels: preservedLabels
                };
                // Only update description if provided
                if (metadata.description !== undefined) {
                    updateData.description = metadata.description;
                }
                // Only update priority if provided
                if (metadata.priority !== undefined) {
                    updateData.priority = metadata.priority;
                }
                // Only update due date if provided
                if (metadata.dueString !== undefined) {
                    updateData.dueString = metadata.dueString;
                }
                // Only update deadline if provided
                if (metadata.deadline !== undefined) {
                    updateData.deadline = metadata.deadline;
                }
                // Don't update content - preserve existing content (including * prefix)
                await this.updateTask(existingMetadataTask.id, updateData);
            } else {
                // Create new metadata task with * prefix
                const newTaskContent = `* ${project.name}`;
                const newTaskLabels = [
                    'project-metadata'
                ];
                if (metadata.category === 'area') {
                    newTaskLabels.push('area-of-responsibility');
                } else if (metadata.category === 'project') {
                    newTaskLabels.push('project-type');
                }
                await this.createTask(newTaskContent, {
                    projectId,
                    description: metadata.description || '',
                    labels: newTaskLabels,
                    ...metadata.priority && {
                        priority: metadata.priority
                    },
                    ...metadata.dueString && {
                        dueString: metadata.dueString
                    },
                    ...metadata.deadline && {
                        deadline: metadata.deadline
                    }
                });
            }
            return true;
        } catch (error) {
            console.error('Error setting project metadata:', error);
            throw new Error('Failed to set project metadata');
        }
    }
    // Legacy method for backward compatibility
    static async setProjectDescription(projectId, description) {
        return this.setProjectMetadata(projectId, {
            description
        });
    }
    // Project hierarchy with metadata
    static async fetchProjectHierarchyWithMetadata() {
        try {
            // 1. Get all projects
            const projects = await this.getProjects();
            // 2. Get metadata for all projects in parallel
            const projectsWithMetadata = await Promise.all(projects.map(async (project)=>{
                const metadata = await this.getProjectMetadata(project.id);
                return {
                    ...project,
                    description: metadata?.description || '',
                    category: metadata?.category || null,
                    priority: metadata?.priority || null,
                    due: metadata?.due,
                    deadline: metadata?.deadline
                };
            }));
            // 3. Build hierarchy map
            const rootProjects = projectsWithMetadata.filter((p)=>!p.parentId);
            const childProjects = projectsWithMetadata.filter((p)=>p.parentId);
            const hierarchy = rootProjects.map((parent)=>({
                    ...parent,
                    children: childProjects.filter((child)=>child.parentId === parent.id)
                }));
            return {
                flat: projectsWithMetadata,
                hierarchical: hierarchy
            };
        } catch (error) {
            console.error('Error fetching project hierarchy:', error);
            throw new Error('Failed to fetch project hierarchy with metadata');
        }
    }
    // Legacy method for backward compatibility
    static async fetchProjectHierarchyWithDescriptions() {
        const result = await this.fetchProjectHierarchyWithMetadata();
        return {
            flat: result.flat.map((p)=>({
                    ...p,
                    description: p.description
                })),
            hierarchical: result.hierarchical.map((p)=>({
                    ...p,
                    description: p.description,
                    children: p.children.map((c)=>({
                            ...c,
                            description: c.description
                        }))
                }))
        };
    }
    // Generate context for LLM requests
    static async generateTodoistContext() {
        try {
            const { flat, hierarchical } = await this.fetchProjectHierarchyWithMetadata();
            return {
                projects: flat,
                hierarchy: hierarchical,
                summary: {
                    totalProjects: flat.length,
                    projectsWithDescriptions: flat.filter((p)=>p.description.trim()).length,
                    rootProjects: hierarchical.length,
                    areas: flat.filter((p)=>p.category === 'area').length,
                    projects: flat.filter((p)=>p.category === 'project').length
                }
            };
        } catch (error) {
            console.error('Error generating Todoist context:', error);
            throw new Error('Failed to generate Todoist context');
        }
    }
}
}}),
"[project]/app/api/todoist/projects/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$todoist$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/todoist-api.ts [app-route] (ecmascript)");
;
;
async function GET() {
    try {
        const projects = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$todoist$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TodoistApiClient"].getProjects();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(projects);
    } catch (error) {
        console.error('API Error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to fetch projects'
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__ffa0f832._.js.map