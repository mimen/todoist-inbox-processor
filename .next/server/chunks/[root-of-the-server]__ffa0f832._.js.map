{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file:///Users/mimen/Documents/GitHub/todoist-mcp/todoist-inbox-processor/lib/todoist-api.ts"],"sourcesContent":["import { TodoistApi } from '@doist/todoist-api-typescript'\n\n// Initialize Todoist API client\nconst api = new TodoistApi(process.env.TODOIST_API_KEY!)\n\nexport interface TodoistTaskApi {\n  id: string\n  content: string\n  description: string\n  projectId: string\n  priority: 1 | 2 | 3 | 4\n  labels: string[]\n  due?: {\n    date: string\n    string: string\n    datetime?: string\n  }\n  createdAt: string\n  isCompleted: boolean\n}\n\nexport interface TodoistProjectApi {\n  id: string\n  name: string\n  color: string\n  isInboxProject: boolean\n  parentId?: string\n}\n\nexport interface TodoistLabelApi {\n  id: string\n  name: string\n  color: string\n}\n\nexport interface TaskUpdateRequest {\n  content?: string\n  description?: string\n  projectId?: string\n  priority?: 1 | 2 | 3 | 4\n  labels?: string[]\n  dueString?: string\n}\n\nexport class TodoistApiClient {\n  // Fetch all projects\n  static async getProjects(): Promise<TodoistProjectApi[]> {\n    try {\n      const response = await api.getProjects()\n      console.log('Projects response:', response)\n      console.log('Projects response type:', typeof response)\n      console.log('Projects response keys:', Object.keys(response || {}))\n      \n      // Handle different response formats\n      let projects: any[]\n      if (Array.isArray(response)) {\n        projects = response\n      } else if (response && typeof response === 'object') {\n        // Try common pagination field names\n        projects = (response as any).data || \n                  (response as any).items || \n                  (response as any).projects ||\n                  (response as any).results ||\n                  []\n      } else {\n        projects = []\n      }\n\n      console.log('Extracted projects:', projects)\n      console.log('Projects array length:', projects.length)\n\n      // Filter out null/undefined items\n      const validProjects = projects.filter(project => project && project.id)\n\n      return validProjects.map((project: any) => ({\n        id: project.id,\n        name: project.name,\n        color: project.color,\n        isInboxProject: project.inboxProject || false,\n        parentId: project.parentId || undefined,\n      }))\n    } catch (error) {\n      console.error('Error fetching projects:', error)\n      throw new Error('Failed to fetch projects')\n    }\n  }\n\n  // Fetch all labels\n  static async getLabels(): Promise<TodoistLabelApi[]> {\n    try {\n      const response = await api.getLabels()\n      console.log('Labels response:', response)\n      console.log('Labels response keys:', Object.keys(response || {}))\n      \n      // Handle different response formats\n      let labels: any[]\n      if (Array.isArray(response)) {\n        labels = response\n      } else if (response && typeof response === 'object') {\n        // Try common pagination field names\n        labels = (response as any).data || \n                (response as any).items || \n                (response as any).labels ||\n                (response as any).results ||\n                []\n      } else {\n        labels = []\n      }\n\n      console.log('Extracted labels:', labels)\n      \n      // Filter out null/undefined items\n      const validLabels = labels.filter(label => label && label.id)\n\n      return validLabels.map((label: any) => ({\n        id: label.id,\n        name: label.name,\n        color: label.color,\n      }))\n    } catch (error) {\n      console.error('Error fetching labels:', error)\n      throw new Error('Failed to fetch labels')\n    }\n  }\n\n  // Fetch active tasks (inbox tasks or all tasks)\n  static async getTasks(filter?: string): Promise<TodoistTaskApi[]> {\n    try {\n      const response = filter ? await api.getTasks({ filter } as any) : await api.getTasks()\n      console.log('Tasks response:', response)\n      console.log('Tasks response keys:', Object.keys(response || {}))\n      \n      // Handle different response formats\n      let tasks: any[]\n      if (Array.isArray(response)) {\n        tasks = response\n      } else if (response && typeof response === 'object') {\n        // Try common pagination field names\n        tasks = (response as any).data || \n               (response as any).items || \n               (response as any).tasks ||\n               (response as any).results ||\n               []\n      } else {\n        tasks = []\n      }\n\n      console.log('Extracted tasks:', tasks)\n      \n      // Filter out null/undefined items\n      const validTasks = tasks.filter(task => task && task.id)\n\n      return validTasks.map((task: any) => ({\n        id: task.id,\n        content: task.content,\n        description: task.description || '',\n        projectId: task.projectId,\n        priority: task.priority as 1 | 2 | 3 | 4,\n        labels: task.labels || [],\n        due: task.due ? {\n          date: task.due.date,\n          string: task.due.string,\n          datetime: task.due.datetime || undefined,\n        } : undefined,\n        createdAt: task.createdAt,\n        isCompleted: task.isCompleted || false,\n      }))\n    } catch (error) {\n      console.error('Error fetching tasks:', error)\n      throw new Error('Failed to fetch tasks')\n    }\n  }\n\n  // Get inbox tasks specifically\n  static async getInboxTasks(): Promise<TodoistTaskApi[]> {\n    return this.getTasks()\n  }\n\n  // Get tasks for a specific project\n  static async getProjectTasks(projectId: string): Promise<TodoistTaskApi[]> {\n    try {\n      const response = await api.getTasks({ projectId } as any)\n      console.log(`Tasks response for project ${projectId}:`, response)\n      \n      // Handle different response formats\n      let tasks: any[]\n      if (Array.isArray(response)) {\n        tasks = response\n      } else if (response && typeof response === 'object') {\n        // Try common pagination field names\n        tasks = (response as any).data || \n               (response as any).items || \n               (response as any).tasks ||\n               (response as any).results ||\n               []\n      } else {\n        tasks = []\n      }\n\n      console.log(`Extracted tasks for project ${projectId}:`, tasks)\n      \n      // Filter out null/undefined items\n      const validTasks = tasks.filter(task => task && task.id)\n\n      return validTasks.map((task: any) => ({\n        id: task.id,\n        content: task.content,\n        description: task.description || '',\n        projectId: task.projectId,\n        priority: task.priority as 1 | 2 | 3 | 4,\n        labels: task.labels || [],\n        due: task.due ? {\n          date: task.due.date,\n          string: task.due.string,\n          datetime: task.due.datetime || undefined,\n        } : undefined,\n        createdAt: task.createdAt,\n        isCompleted: task.isCompleted || false,\n      }))\n    } catch (error) {\n      console.error(`Error fetching tasks for project ${projectId}:`, error)\n      throw new Error('Failed to fetch project tasks')\n    }\n  }\n\n  // Move task to a different project using Sync API v9\n  static async moveTaskToProject(taskId: string, projectId: string): Promise<boolean> {\n    try {\n      console.log('üîÑ Moving task via Sync API:', { taskId, projectId })\n      \n      // Generate a unique UUID for the command\n      const uuid = crypto.randomUUID()\n      \n      const response = await fetch('https://api.todoist.com/sync/v9/sync', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${process.env.TODOIST_API_KEY}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          commands: [\n            {\n              type: 'item_move',\n              args: {\n                id: taskId,\n                project_id: projectId\n              },\n              uuid: uuid\n            }\n          ]\n        }),\n      })\n      \n      if (!response.ok) {\n        const errorText = await response.text()\n        console.error('Sync API move failed:', response.status, errorText)\n        throw new Error(`Sync API move failed: ${response.status} ${errorText}`)\n      }\n      \n      const result = await response.json()\n      console.log('‚úÖ Sync API move result:', result)\n      \n      // Check if the command was successful\n      if (result.sync_status && result.sync_status[uuid] === 'ok') {\n        console.log('‚úÖ Task move confirmed successful')\n        return true\n      } else {\n        console.error('‚ùå Task move failed:', result.sync_status)\n        throw new Error(`Task move failed: ${JSON.stringify(result.sync_status)}`)\n      }\n    } catch (error) {\n      console.error('‚ùå Sync API move error:', error)\n      throw error\n    }\n  }\n\n  // Update a task\n  static async updateTask(taskId: string, updates: TaskUpdateRequest): Promise<boolean> {\n    try {\n      console.log('TodoistApiClient.updateTask called with:', { taskId, updates })\n      \n      // Handle project move separately using REST API\n      if (updates.projectId && updates.projectId !== '') {\n        try {\n          const projects = await this.getProjects()\n          const targetProject = projects.find(p => p.id === updates.projectId)\n          if (!targetProject) {\n            console.error('Target project not found:', updates.projectId)\n            console.log('Available projects:', projects.map(p => ({ id: p.id, name: p.name })))\n            throw new Error(`Project with ID ${updates.projectId} not found`)\n          }\n          console.log('Target project found:', { id: targetProject.id, name: targetProject.name })\n          \n          // Use REST API for project move\n          await this.moveTaskToProject(taskId, updates.projectId)\n        } catch (moveError) {\n          console.error('‚ùå Project move failed:', moveError)\n          throw new Error(`Failed to move task to project: ${moveError}`)\n        }\n      }\n      \n      // Build updates object for other fields (excluding projectId)\n      const cleanUpdates: any = {}\n      \n      if (updates.content !== undefined) cleanUpdates.content = updates.content\n      if (updates.description !== undefined) cleanUpdates.description = updates.description\n      if (updates.priority !== undefined) cleanUpdates.priority = updates.priority\n      if (updates.labels !== undefined) cleanUpdates.labels = updates.labels\n      if (updates.dueString !== undefined) cleanUpdates.dueString = updates.dueString\n      \n      // Only update other fields if there are any\n      if (Object.keys(cleanUpdates).length > 0) {\n        console.log('üìù Updating task fields:', cleanUpdates)\n        const result = await api.updateTask(taskId, cleanUpdates)\n        console.log('‚úÖ Update task result:', result)\n      } else {\n        console.log('‚ÑπÔ∏è  No additional fields to update (only project was changed)')\n      }\n      \n      return true\n    } catch (error) {\n      console.error('Error updating task:', error)\n      console.error('Full error details:', JSON.stringify(error, null, 2))\n      throw new Error('Failed to update task')\n    }\n  }\n\n  // Close (complete) a task\n  static async closeTask(taskId: string): Promise<boolean> {\n    try {\n      await api.closeTask(taskId)\n      return true\n    } catch (error) {\n      console.error('Error closing task:', error)\n      throw new Error('Failed to close task')\n    }\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 437, "column": 0}, "map": {"version":3,"sources":["file:///Users/mimen/Documents/GitHub/todoist-mcp/todoist-inbox-processor/app/api/todoist/projects/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { TodoistApiClient } from '@/lib/todoist-api'\n\nexport async function GET() {\n  try {\n    const projects = await TodoistApiClient.getProjects()\n    return NextResponse.json(projects)\n  } catch (error) {\n    console.error('API Error:', error)\n    return NextResponse.json(\n      { error: 'Failed to fetch projects' },\n      { status: 500 }\n    )\n  }\n}"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,WAAW,MAAM,uHAAA,CAAA,mBAAgB,CAAC,WAAW;QACnD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,cAAc;QAC5B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}