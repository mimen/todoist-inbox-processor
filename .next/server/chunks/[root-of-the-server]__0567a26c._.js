module.exports = {

"[project]/.next-internal/server/app/api/projects/with-descriptions/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[project]/lib/todoist-api.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "TodoistApiClient": (()=>TodoistApiClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$doist$2f$todoist$2d$api$2d$typescript$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@doist/todoist-api-typescript/dist/index.js [app-route] (ecmascript)");
;
// Initialize Todoist API client
const api = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$doist$2f$todoist$2d$api$2d$typescript$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TodoistApi"](process.env.TODOIST_API_KEY);
class TodoistApiClient {
    // Fetch all projects
    static async getProjects() {
        try {
            const response = await api.getProjects();
            console.log('Projects response:', response);
            console.log('Projects response type:', typeof response);
            console.log('Projects response keys:', Object.keys(response || {}));
            // Handle different response formats
            let projects;
            if (Array.isArray(response)) {
                projects = response;
            } else if (response && typeof response === 'object') {
                // Try common pagination field names
                projects = response.data || response.items || response.projects || response.results || [];
            } else {
                projects = [];
            }
            console.log('Extracted projects:', projects);
            console.log('Projects array length:', projects.length);
            // Filter out null/undefined items
            const validProjects = projects.filter((project)=>project && project.id);
            return validProjects.map((project)=>({
                    id: project.id,
                    name: project.name,
                    color: project.color,
                    isInboxProject: project.inboxProject || false,
                    parentId: project.parentId || undefined
                }));
        } catch (error) {
            console.error('Error fetching projects:', error);
            throw new Error('Failed to fetch projects');
        }
    }
    // Fetch all labels
    static async getLabels() {
        try {
            const response = await api.getLabels();
            console.log('Labels response:', response);
            console.log('Labels response keys:', Object.keys(response || {}));
            // Handle different response formats
            let labels;
            if (Array.isArray(response)) {
                labels = response;
            } else if (response && typeof response === 'object') {
                // Try common pagination field names
                labels = response.data || response.items || response.labels || response.results || [];
            } else {
                labels = [];
            }
            console.log('Extracted labels:', labels);
            // Filter out null/undefined items
            const validLabels = labels.filter((label)=>label && label.id);
            return validLabels.map((label)=>({
                    id: label.id,
                    name: label.name,
                    color: label.color
                }));
        } catch (error) {
            console.error('Error fetching labels:', error);
            throw new Error('Failed to fetch labels');
        }
    }
    // Fetch active tasks (inbox tasks or all tasks)
    static async getTasks(filter) {
        try {
            const response = filter ? await api.getTasks({
                filter
            }) : await api.getTasks();
            console.log('Tasks response:', response);
            console.log('Tasks response keys:', Object.keys(response || {}));
            // Handle different response formats
            let tasks;
            if (Array.isArray(response)) {
                tasks = response;
            } else if (response && typeof response === 'object') {
                // Try common pagination field names
                tasks = response.data || response.items || response.tasks || response.results || [];
            } else {
                tasks = [];
            }
            console.log('Extracted tasks:', tasks);
            // Filter out null/undefined items
            const validTasks = tasks.filter((task)=>task && task.id);
            return validTasks.map((task)=>({
                    id: task.id,
                    content: task.content,
                    description: task.description || '',
                    projectId: task.projectId,
                    priority: task.priority,
                    labels: task.labels || [],
                    due: task.due ? {
                        date: task.due.date,
                        string: task.due.string,
                        datetime: task.due.datetime || undefined
                    } : undefined,
                    createdAt: task.createdAt,
                    isCompleted: task.isCompleted || false
                }));
        } catch (error) {
            console.error('Error fetching tasks:', error);
            throw new Error('Failed to fetch tasks');
        }
    }
    // Get inbox tasks specifically
    static async getInboxTasks() {
        return this.getTasks();
    }
    // Get tasks for a specific project
    static async getProjectTasks(projectId) {
        try {
            const response = await api.getTasks({
                projectId
            });
            console.log(`Tasks response for project ${projectId}:`, response);
            // Handle different response formats
            let tasks;
            if (Array.isArray(response)) {
                tasks = response;
            } else if (response && typeof response === 'object') {
                // Try common pagination field names
                tasks = response.data || response.items || response.tasks || response.results || [];
            } else {
                tasks = [];
            }
            console.log(`Extracted tasks for project ${projectId}:`, tasks);
            // Filter out null/undefined items
            const validTasks = tasks.filter((task)=>task && task.id);
            return validTasks.map((task)=>({
                    id: task.id,
                    content: task.content,
                    description: task.description || '',
                    projectId: task.projectId,
                    priority: task.priority,
                    labels: task.labels || [],
                    due: task.due ? {
                        date: task.due.date,
                        string: task.due.string,
                        datetime: task.due.datetime || undefined
                    } : undefined,
                    createdAt: task.createdAt,
                    isCompleted: task.isCompleted || false
                }));
        } catch (error) {
            console.error(`Error fetching tasks for project ${projectId}:`, error);
            throw new Error('Failed to fetch project tasks');
        }
    }
    // Move task to a different project using Sync API v9
    static async moveTaskToProject(taskId, projectId) {
        try {
            console.log('ðŸ”„ Moving task via Sync API:', {
                taskId,
                projectId
            });
            // Generate a unique UUID for the command
            const uuid = crypto.randomUUID();
            const response = await fetch('https://api.todoist.com/sync/v9/sync', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${process.env.TODOIST_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    commands: [
                        {
                            type: 'item_move',
                            args: {
                                id: taskId,
                                project_id: projectId
                            },
                            uuid: uuid
                        }
                    ]
                })
            });
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Sync API move failed:', response.status, errorText);
                throw new Error(`Sync API move failed: ${response.status} ${errorText}`);
            }
            const result = await response.json();
            console.log('âœ… Sync API move result:', result);
            // Check if the command was successful
            if (result.sync_status && result.sync_status[uuid] === 'ok') {
                console.log('âœ… Task move confirmed successful');
                return true;
            } else {
                console.error('âŒ Task move failed:', result.sync_status);
                throw new Error(`Task move failed: ${JSON.stringify(result.sync_status)}`);
            }
        } catch (error) {
            console.error('âŒ Sync API move error:', error);
            throw error;
        }
    }
    // Update a task
    static async updateTask(taskId, updates) {
        try {
            console.log('TodoistApiClient.updateTask called with:', {
                taskId,
                updates
            });
            // Handle project move separately using REST API
            if (updates.projectId && updates.projectId !== '') {
                try {
                    const projects = await this.getProjects();
                    const targetProject = projects.find((p)=>p.id === updates.projectId);
                    if (!targetProject) {
                        console.error('Target project not found:', updates.projectId);
                        console.log('Available projects:', projects.map((p)=>({
                                id: p.id,
                                name: p.name
                            })));
                        throw new Error(`Project with ID ${updates.projectId} not found`);
                    }
                    console.log('Target project found:', {
                        id: targetProject.id,
                        name: targetProject.name
                    });
                    // Use REST API for project move
                    await this.moveTaskToProject(taskId, updates.projectId);
                } catch (moveError) {
                    console.error('âŒ Project move failed:', moveError);
                    throw new Error(`Failed to move task to project: ${moveError}`);
                }
            }
            // Build updates object for other fields (excluding projectId)
            const cleanUpdates = {};
            if (updates.content !== undefined) cleanUpdates.content = updates.content;
            if (updates.description !== undefined) cleanUpdates.description = updates.description;
            if (updates.priority !== undefined) cleanUpdates.priority = updates.priority;
            if (updates.labels !== undefined) cleanUpdates.labels = updates.labels;
            if (updates.dueString !== undefined) cleanUpdates.dueString = updates.dueString;
            // Only update other fields if there are any
            if (Object.keys(cleanUpdates).length > 0) {
                console.log('ðŸ“ Updating task fields:', cleanUpdates);
                const result = await api.updateTask(taskId, cleanUpdates);
                console.log('âœ… Update task result:', result);
            } else {
                console.log('â„¹ï¸  No additional fields to update (only project was changed)');
            }
            return true;
        } catch (error) {
            console.error('Error updating task:', error);
            console.error('Full error details:', JSON.stringify(error, null, 2));
            throw new Error('Failed to update task');
        }
    }
    // Close (complete) a task
    static async closeTask(taskId) {
        try {
            await api.closeTask(taskId);
            return true;
        } catch (error) {
            console.error('Error closing task:', error);
            throw new Error('Failed to close task');
        }
    }
    // Create a new task
    static async createTask(content, options) {
        try {
            const taskData = {
                content,
                ...options?.description && {
                    description: options.description
                },
                ...options?.projectId && {
                    projectId: options.projectId
                },
                ...options?.priority && {
                    priority: options.priority
                },
                ...options?.labels && {
                    labels: options.labels
                },
                ...options?.dueString && {
                    dueString: options.dueString
                }
            };
            const response = await api.addTask(taskData);
            return {
                id: response.id,
                content: response.content,
                description: response.description || '',
                projectId: response.projectId,
                priority: response.priority,
                labels: response.labels || [],
                due: response.due ? {
                    date: response.due.date,
                    string: response.due.string,
                    datetime: response.due.datetime || undefined
                } : undefined,
                createdAt: response.createdAt || new Date().toISOString(),
                isCompleted: !!response.completedAt
            };
        } catch (error) {
            console.error('Error creating task:', error);
            throw new Error('Failed to create task');
        }
    }
    // Project description helpers
    static async getProjectDescription(projectId) {
        try {
            const tasks = await this.getProjectTasks(projectId);
            const descriptionTask = tasks.find((task)=>task.content.startsWith('* ') && task.labels.includes('project description'));
            if (descriptionTask) {
                // Remove the '* ' prefix and return the description
                return descriptionTask.content.substring(2).trim();
            }
            return null;
        } catch (error) {
            console.error('Error fetching project description:', error);
            return null;
        }
    }
    static async setProjectDescription(projectId, description) {
        try {
            const tasks = await this.getProjectTasks(projectId);
            const existingDescriptionTask = tasks.find((task)=>task.content.startsWith('* ') && task.labels.includes('project description'));
            if (existingDescriptionTask) {
                // Update existing description task
                await this.updateTask(existingDescriptionTask.id, {
                    content: `* ${description}`
                });
            } else {
                // Create new description task
                await this.createTask(`* ${description}`, {
                    projectId,
                    labels: [
                        'project description'
                    ],
                    priority: 1 // P4 (lowest priority) but still appears at top due to * prefix
                });
            }
            return true;
        } catch (error) {
            console.error('Error setting project description:', error);
            throw new Error('Failed to set project description');
        }
    }
    // Project hierarchy with descriptions
    static async fetchProjectHierarchyWithDescriptions() {
        try {
            // 1. Get all projects
            const projects = await this.getProjects();
            // 2. Get descriptions for all projects in parallel
            const projectsWithDescriptions = await Promise.all(projects.map(async (project)=>{
                const description = await this.getProjectDescription(project.id);
                return {
                    ...project,
                    description: description || ''
                };
            }));
            // 3. Build hierarchy map
            const rootProjects = projectsWithDescriptions.filter((p)=>!p.parentId);
            const childProjects = projectsWithDescriptions.filter((p)=>p.parentId);
            const hierarchy = rootProjects.map((parent)=>({
                    ...parent,
                    children: childProjects.filter((child)=>child.parentId === parent.id)
                }));
            return {
                flat: projectsWithDescriptions,
                hierarchical: hierarchy
            };
        } catch (error) {
            console.error('Error fetching project hierarchy:', error);
            throw new Error('Failed to fetch project hierarchy with descriptions');
        }
    }
    // Generate context for LLM requests
    static async generateTodoistContext() {
        try {
            const { flat, hierarchical } = await this.fetchProjectHierarchyWithDescriptions();
            return {
                projects: flat,
                hierarchy: hierarchical,
                summary: {
                    totalProjects: flat.length,
                    projectsWithDescriptions: flat.filter((p)=>p.description.trim()).length,
                    rootProjects: hierarchical.length
                }
            };
        } catch (error) {
            console.error('Error generating Todoist context:', error);
            throw new Error('Failed to generate Todoist context');
        }
    }
}
}}),
"[project]/app/api/projects/with-descriptions/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$todoist$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/todoist-api.ts [app-route] (ecmascript)");
;
;
async function GET() {
    try {
        const { flat } = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$todoist$2d$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TodoistApiClient"].fetchProjectHierarchyWithDescriptions();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(flat);
    } catch (error) {
        console.error('Error fetching projects with descriptions:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to fetch projects with descriptions'
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__0567a26c._.js.map